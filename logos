#!/bin/bash -eu

SELF="$0"
WORKSPACE_DIR="$(dirname "$(realpath "$0")")"

AWS_REGION="${AWS_REGION:-"us-east-2"}"
# TODO create a role with diminished permissions
AWS_SSO_ROLE="${AWS_SSO_ROLE:-"AWSAdministratorAccess"}"
AWS_SSO_URL="${AWS_SSO_URL:-"https://logos-dev.awsapps.com/start"}"
BAZEL="bazelisk"

PG_TUNNEL_HOST="127.0.0.1"
PG_TUNNEL_PORT=15432
PG_TUNNEL_SOCAT_PID="/tmp/logos_rds_tunnel_socat_pid"
PG_TUNNEL_PORT_FORWARD_PID="/tmp/logos_rds_tunnel_port_forward_pid"
PG_TUNNEL_LOCAL_PORT=15432
PG_TUNNEL_REMOTE_PORT=5432
PG_AUTH_PORT=5432
PG_AUTH_HOST="db-rw.logos.dev"
PG_DB_NAME="logos"
PG_DB_MIGRATION_USER="root"

trap 'cleanup' INT TERM ERR

cleanup() {
    trap - INT TERM ERR
    rds_tunnel_down
}

stderr() {
  echo -e "$@" 2>&1
}

dev_config_aws_profile() {
  AWS_ACCOUNT_ID="${AWS_ACCOUNT_ID:-""}"

  while [ -z "$AWS_ACCOUNT_ID" ]; do
    read -r -p "AWS Account ID: " AWS_ACCOUNT_ID
  done
  stderr

  cat <<EOF
[profile default]
sso_session = logos-dev
sso_account_id = $AWS_ACCOUNT_ID
sso_role_name = $AWS_SSO_ROLE
region = $AWS_REGION

[sso-session logos-dev]
sso_start_url = $AWS_SSO_URL
sso_region = $AWS_REGION
sso_registration_scopes = sso:account:access
EOF
}

dev_config_aws_bzl() {
  cat <<EOF
ACCOUNT="$AWS_ACCOUNT_ID"
REGION="$AWS_REGION"
EOF
}

dev_config() {
    case "${1:-"help"}" in
        aws_profile)
            shift 1
            dev_config_aws_profile "$@"
            ;;
        aws_bzl)
            shift 1
            dev_config_aws_bzl "$@"
            ;;
        *)
            help
            ;;
    esac
}

dev_env() {
    CONSOLE_POD_NAME="pod/$(kubectl get pods -l app=console -o jsonpath="{.items[0].metadata.name}")"

    kubectl wait --for=condition=Ready "$CONSOLE_POD_NAME"

    STORAGE_PG_BACKEND_HOST="$(kubectl exec "$CONSOLE_POD_NAME" -- nslookup -type=cname "$PG_AUTH_HOST" | grep "canonical name = " | cut -d' ' -f4 | sed -e 's/\.$//')"

    export STORAGE_PG_BACKEND_HOST
    export STORAGE_PG_BACKEND_JDBC_URL="jdbc:postgresql://localhost:15432/logos"
    export STORAGE_PG_BACKEND_USER="storage"
}

dev_setup() {
    mkdir -p ~/.aws
    dev_config_aws_profile > ~/.aws/config

    mkdir -p $WORKSPACE_DIR/cfg
    dev_config_aws_bzl > $WORKSPACE_DIR/cfg/aws.bzl

    aws sso login

    ACCOUNT="$(aws sts get-caller-identity --query "Account" --output text)"
    STACK="logos-eks"
    ROLE_ARN="$(aws cloudformation describe-stacks \
                        --stack-name $STACK \
                        --query "Stacks[0].Outputs[?starts_with(OutputKey, \`logoseksConfigCommand\`)].OutputValue | [0]" \
                        --output text \
                        | cut -d' ' -f 9)"

    echo "Updating kubeconfig for $STACK in $AWS_REGION"
    aws eks update-kubeconfig \
                --name logos-eks \
                --region "$AWS_REGION" \
                --role-arn "$ROLE_ARN"

    rds_setup
}

dev() {
    case "${1:-"help"}" in
        config)
            shift 1
            dev_config "$@"
            ;;
        env)
            shift 1
            dev_env "$@"
            ;;
        setup)
            shift 1
            dev_setup "$@"
            ;;
        *)
            help
            ;;
    esac
}

console_pod() {
    kubectl get pods -l app=console -o jsonpath="{.items[0].metadata.name}"
}

console() {
  kubectl exec -it "$(console_pod)" -- sh
}

rds_tunnel() {
    rds_tunnel_up
    sleep infinity
}

rds_tunnel_up() {
  CONSOLE_POD_NAME="$(console_pod)"
  kubectl exec "$CONSOLE_POD_NAME" -- killall socat || true

  if ! kill -0 "$(cat "$PG_TUNNEL_SOCAT_PID")"
  then
    kubectl exec "$CONSOLE_POD_NAME" -- socat TCP-LISTEN:$PG_TUNNEL_REMOTE_PORT,fork,reuseaddr TCP:$PG_AUTH_HOST:$PG_TUNNEL_REMOTE_PORT &
    echo "$!" > "$PG_TUNNEL_SOCAT_PID"
  fi

  if ! kill -0 "$(cat "$PG_TUNNEL_PORT_FORWARD_PID")"
  then
    kubectl port-forward "$CONSOLE_POD_NAME" "$PG_TUNNEL_LOCAL_PORT:$PG_TUNNEL_REMOTE_PORT" &
    echo "$!" > "$PG_TUNNEL_PORT_FORWARD_PID"
  fi

  echo "Checking for tunnel connectivity."

  PGPASSWORD="$(rds_clusteradmin_password)"
  export PGPASSWORD

  until _psql --user clusteradmin -c "select 1" logos; do
    sleep 1
  done

  unset PGPASSWORD
}


rds_tunnel_down() {
    CONSOLE_POD_NAME="$(console_pod)"

    stderr
    stderr "Disconnecting kubectl port forward."
    kill -9 "$(cat $PG_TUNNEL_PORT_FORWARD_PID)" || true

    stderr
    stderr "Killing kubectl exec socat."
    kill -9 "$(cat $PG_TUNNEL_SOCAT_PID)" || true

    stderr
    stderr "Killing socat in console pod."
    kubectl exec "$CONSOLE_POD_NAME" -- killall socat
}

rds_setup() {
    PGPASSWORD="$(rds_clusteradmin_password)" _psql -U clusteradmin template1 \
<<SQL
    do language plpgsql \$\$
        begin
            if not exists (
                select from pg_roles where rolname = '$PG_DB_MIGRATION_USER'
            ) then
                execute 'create role $PG_DB_MIGRATION_USER';
            end if;
        end;
    \$\$;

    alter database logos owner to $PG_DB_MIGRATION_USER;

    alter role $PG_DB_MIGRATION_USER login;
    grant rds_iam to $PG_DB_MIGRATION_USER;
    grant rds_superuser to $PG_DB_MIGRATION_USER;
SQL
}

rds_migrate() {
    rds_tunnel_up

    SQITCH_PASSWORD="$(rds_token "$PG_DB_MIGRATION_USER")"
    export SQITCH_PASSWORD

    pushd "$WORKSPACE_DIR/dev/logos/stack/service/storage/migrations"
    sqitch deploy --db-name "$PG_DB_NAME" \
                  --db-user "$PG_DB_MIGRATION_USER" \
                  --db-host "$PG_TUNNEL_HOST" \
                  --db-port "$PG_TUNNEL_PORT"
    popd

    unset SQITCH_PASSWORD
}

rds_token() {
    USERNAME=$1; shift 1

    aws rds generate-db-auth-token \
              --hostname "$STORAGE_PG_BACKEND_HOST" \
              --port "$PG_AUTH_PORT" \
              --region "$AWS_REGION" \
              --username "$USERNAME"
}

rds() {
    case "${1:-"help"}" in
        setup)
            shift 1
            rds_setup "$@"
            ;;
        migrate)
            shift 1
            rds_migrate "$@"
            ;;
        token)
            shift 1
            rds_token "$@"
            ;;
        tunnel)
            shift 1
            rds_tunnel "$@"
            ;;
        *)
            help
            ;;
    esac
}

rds_clusteradmin_password() {
  aws secretsmanager \
      get-secret-value \
      --secret-id "$(aws secretsmanager list-secrets \
                                        --query "SecretList[?starts_with(Name, \`logosrdsdbclusterSecret\`)].Name | [0]" \
                                        --output text)" \
      --query "SecretString" \
      --output text | jq -r ".password"
}

deploy() {
    $BAZEL build --config=remote //dev/logos/infra:cdk_deploy

    ACCOUNT="$(aws sts get-caller-identity --query "Account" --output text)"
    echo "Logging into ECR for $ACCOUNT in $AWS_REGION"
    aws ecr get-login-password \
                --region "$AWS_REGION" \
                | docker login \
                    --username AWS \
                    --password-stdin "$ACCOUNT.dkr.ecr.$AWS_REGION.amazonaws.com"

    $BAZEL run --config=remote //dev/logos/stack/service/console:console.apply

    dev_env

    rds_tunnel_up
    rds_migrate

    $BAZEL run --config=remote //dev/logos/stack/service/backend:backend.apply
    $BAZEL run --config=remote //dev/logos/stack/service/envoy:envoy.apply
    $BAZEL run --config=remote //dev/logos/stack/service/client:client.apply
    $BAZEL run --config=remote //dev/logos/stack/ingress/nginx:nginx.apply
}

_psql() {
    PGPASSWORD="${PGPASSWORD:-$(rds_token "$PG_DB_MIGRATION_USER")}" \
        psql --host "$PG_TUNNEL_HOST" \
             --port "$PG_TUNNEL_PORT" \
             -U "$PG_DB_MIGRATION_USER" \
             "$@"
}

logos() {
    case "${1:-"help"}" in
        console)
            shift 1
            console "$@"
            ;;
        dev)
            shift 1
            dev "$@"
            ;;
        deploy)
            shift 1
            deploy "$@"
            ;;
        rds)
            shift 1
            rds "$@"
            ;;
        psql)
            shift 1
            rds_tunnel_up
            _psql "$@"
            ;;
        *)
            help
            ;;
    esac
}

help() {
    stderr
    stderr "$SELF \e[4mcommand\e[0m ..."
    stderr
    exit 1
}

logos "$@"
cleanup